// This script is designed to test the solidity smart contract - SuppyChain.sol -- and the various functions within
// Declare a variable and assign the compiled smart contract artifact
var SupplyChain = artifacts.require("SupplyChain");
//const truffleAssert = require("truffle-assertions");

contract("SupplyChain", function(accounts) {
  // Declare few constants and assign a few sample accounts generated by ganache-cli
  var sku = 1;
  var upc = 1;
  const ownerID = accounts[0];
  const originFarmerID = accounts[1];
  const originFarmName = "John Doe";
  const originFarmInformation = "Yarray Valley";
  const originFarmLatitude = "-38.239770";
  const originFarmLongitude = "144.341490";
  var productID = sku + upc;
  const productNotes = "Best beans for Espresso";
  //const productPrice = web3.utils.toWei("1", "ether");
  const productPrice = web3.toWei(1, "ether");
  var itemState = 0;
  const transporterID = accounts[2];
  const bottlingFarmID = accounts[3];
  const distributorID = accounts[4];
  const consumerID = accounts[5];
  const emptyAddress = "0x00000000000000000000000000000000000000";
  const cowAddress = "0x00000000000000000000000000000000000001";

  ///Available Accounts
  ///==================
  ///(0) 0x27d8d15cbc94527cadf5ec14b69519ae23288b95
  ///(1) 0x018c2dabef4904ecbd7118350a0c54dbeae3549a
  ///(2) 0xce5144391b4ab80668965f2cc4f2cc102380ef0a
  ///(3) 0x460c31107dd048e34971e57da2f99f659add4f02
  ///(4) 0xd37b7b8c62be2fdde8daa9816483aebdbd356088
  ///(5) 0x27f184bdc0e7a931b507ddd689d76dba10514bcb
  ///(6) 0xfe0df793060c49edca5ac9c104dd8e3375349978
  ///(7) 0xbd58a85c96cc6727859d853086fe8560bc137632
  ///(8) 0xe07b5ee5f738b2f87f88b99aac9c64ff1e0c7917
  ///(9) 0xbd3ff2e3aded055244d66544c9c059fa0851da44

  console.log("ganache-cli accounts used here...");
  console.log("Contract Owner: accounts[0] ", accounts[0]);
  console.log("Farmer: accounts[1] ", accounts[1]);
  console.log("Transporter: accounts[2] ", accounts[2]);
  console.log("BottlingFarm: accounts[3] ", accounts[3]);
  console.log("Distributor: accounts[4] ", accounts[4]);
  console.log("Consumer: accounts[5] ", accounts[5]);

  //CONTRACT AND ACTORS SETUP
  it("0. Deploy SupplyChain and Register Actors", async () => {
    const supplyChain = await SupplyChain.deployed();

    // Declare and Initialize a variable for event
    var eventsEmitted = [false, false, false, false, false];

    var event0 = supplyChain.FarmerAdded();
    await event0.watch((err, res) => {
      eventsEmitted[0] = true;
      return true;
    });
    // Watch the emitted event RetailerAdded()
    var event1 = supplyChain.TransporterAdded();
    await event1.watch((err, res) => {
      eventsEmitted[1] = true;
      return true;
    });

    // Watch the emitted event RetailerAdded()
    var event2 = supplyChain.BottlingFarmAdded();
    await event2.watch((err, res) => {
      eventsEmitted[2] = true;
      return true;
    });

    // Watch the emitted event DistributorAdded()
    var event3 = supplyChain.DistributorAdded();
    await event3.watch((err, res) => {
      eventsEmitted[3] = true;
      return true;
    });

    // Watch the emitted event RetailerAdded()
    var event4 = supplyChain.ConsumerAdded();
    await event4.watch((err, res) => {
      eventsEmitted[4] = true;

      assert.equal(
        eventsEmitted.every(ev => ev),
        true,
        "Invalid event emitted"
      );
      return true;
    });

    // Mark an item as Harvested by calling function harvestItem()
    let tx;
    tx = await supplyChain.addFarmer(originFarmerID, { from: ownerID });
    tx = await supplyChain.addTransporter(transporterID, { from: ownerID });
    tx = await supplyChain.addBottlingFarm(bottlingFarmID, { from: ownerID });
    tx = await supplyChain.addDistributor(distributorID, { from: ownerID });
    tx = await supplyChain.addConsumer(consumerID, { from: ownerID });
  });

  // 1st Test
  it("Testing smart contract function milkCow() that allows a farmer to get milk", async () => {
    const supplyChain = await SupplyChain.deployed();

    // Declare and Initialize a variable for event
    var eventEmitted = false;

    // Watch the emitted event CowMilked()
    var event = supplyChain.CowMilked();
    await event.watch((err, res) => {
      eventEmitted = true;
    });

    // Mark an item as Harvested by calling function harvestItem()
    await supplyChain.milkCow(
      cowAddress,
      originFarmerID,
      originFarmName,
      originFarmInformation,
      originFarmLatitude,
      originFarmLongitude,
      productNotes
    );

    // Retrieve the just now saved item from blockchain by calling function fetchItem()
    const resultBufferOne = await supplyChain.fetchItemBufferOne.call(upc);
    const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(upc);

    // Verify the result set
    assert.equal(resultBufferOne[0], sku, "Error: Invalid item SKU");
    assert.equal(resultBufferOne[1], upc, "Error: Invalid item UPC");
    assert.equal(
      resultBufferOne[2],
      ownerID,
      "Error: Missing or Invalid ownerID"
    );
    assert.equal(
      resultBufferOne[3],
      originFarmerID,
      "Error: Missing or Invalid originFarmerID"
    );
    assert.equal(
      resultBufferOne[4],
      originFarmName,
      "Error: Missing or Invalid originFarmName"
    );
    assert.equal(
      resultBufferOne[5],
      originFarmInformation,
      "Error: Missing or Invalid originFarmInformation"
    );
    assert.equal(
      resultBufferOne[6],
      originFarmLatitude,
      "Error: Missing or Invalid originFarmLatitude"
    );
    assert.equal(
      resultBufferOne[7],
      originFarmLongitude,
      "Error: Missing or Invalid originFarmLongitude"
    );
    assert.equal(resultBufferTwo[5], 0, "Error: Invalid item State");
    assert.equal(eventEmitted, true, "Invalid event emitted");
  });

  // 2nd Test
  it("Testing smart contract function refrigerate() that allows a farmer to refrigerate milk", async () => {
    const supplyChain = await SupplyChain.deployed();

    // Declare and Initialize a variable for event
    var eventEmitted = false;

    // Watch the emitted event StoredInFarm()
    var event = supplyChain.StoredInFarm();
    await event.watch((err, res) => {
      eventEmitted = true;
    });

    // Mark an item as Processed by calling function processtItem()
    await supplyChain.refrigerate(upc);

    // Retrieve the just now saved item from blockchain by calling function fetchItem()
    const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(upc);

    // Verify the result set
    assert.equal(resultBufferTwo[5], 1, "Error: Invalid milk state");
    assert.equal(eventEmitted, true, "Invalid event emitted");
  });
  // 3rd Test
  it("Testing smart contract function onFarmInspect() that allows a farmer to inspect milk", async () => {
    const supplyChain = await SupplyChain.deployed();

    // Declare and Initialize a variable for event
    var eventEmitted = false;

    // Watch the emitted event StoredInFarm()
    var event = supplyChain.OnFarmInspected();
    await event.watch((err, res) => {
      eventEmitted = true;
    });

    // Mark an item as Processed by calling function processtItem()
    await supplyChain.onFarmInspect(upc);

    // Retrieve the just now saved item from blockchain by calling function fetchItem()
    const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(upc);

    // Verify the result set
    assert.equal(resultBufferTwo[5], 2, "Error: Invalid milk state");
    assert.equal(eventEmitted, true, "Invalid event emitted");
  });
  // 4rd Test
  it("Testing smart contract function pick() that allows a trasponrter to get milk", async () => {
    const supplyChain = await SupplyChain.deployed();

    // Declare and Initialize a variable for event
    var eventEmitted = false;

    // Watch the emitted event StoredInFarm()
    var event = supplyChain.PickedFromFarm();
    await event.watch((err, res) => {
      eventEmitted = true;
    });

    // Mark an item as Processed by calling function processtItem()
    await supplyChain.pick(upc, { from: transporterID });

    // Retrieve the just now saved item from blockchain by calling function fetchItem()
    const resultBufferOne = await supplyChain.fetchItemBufferOne.call(upc);
    const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(upc);

    // Verify the result set
    assert.equal(resultBufferTwo[5], 3, "Error: Invalid milk state");
    assert.equal(
      resultBufferOne[2],
      transporterID,
      "Error: Missing or Invalid ownerID"
    );
    assert.equal(
      resultBufferOne[3],
      originFarmerID,
      "Error: Missing or Invalid originFarmerID"
    );
    assert.equal(
      resultBufferTwo[6],
      transporterID,
      "Error: Invalid transporterID"
    );
    assert.equal(eventEmitted, true, "Invalid event emitted");
  });
  // 5th Test
  it("Testing smart contract function ship() that allows a trasponrter to release milk", async () => {
    const supplyChain = await SupplyChain.deployed();

    // Declare and Initialize a variable for event
    var eventEmitted = false;

    // Watch the emitted event StoredInFarm()
    var event = supplyChain.ShippedToBottlingFarm();
    await event.watch((err, res) => {
      eventEmitted = true;
    });

    // Mark an item as Processed by calling function processtItem()
    await supplyChain.ship(upc, { from: transporterID });

    // Retrieve the just now saved item from blockchain by calling function fetchItem()
    const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(upc);

    // Verify the result set
    assert.equal(resultBufferTwo[5], 4, "Error: Invalid milk state");
  });
  // 6th Test
  it("Testing smart contract function onBottlingFarmInspect() that allows bottling farm to inspect milk", async () => {
    const supplyChain = await SupplyChain.deployed();

    // Declare and Initialize a variable for event
    var eventEmitted = false;

    // Watch the emitted event StoredInFarm()
    var event = supplyChain.OnBottlingFarmInspected();
    await event.watch((err, res) => {
      eventEmitted = true;
    });

    // Mark an item as Processed by calling function processtItem()
    await supplyChain.onBottlingFarmInspect(upc, { from: bottlingFarmID });

    // Retrieve the just now saved item from blockchain by calling function fetchItem()
    const resultBufferOne = await supplyChain.fetchItemBufferOne.call(upc);
    const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(upc);

    // Verify the result set
    assert.equal(resultBufferTwo[5], 5, "Error: Invalid milk state");
    assert.equal(
      resultBufferOne[2],
      bottlingFarmID,
      "Error: Missing or Invalid ownerID"
    );
    assert.equal(
      resultBufferOne[3],
      originFarmerID,
      "Error: Missing or Invalid originFarmerID"
    );
    assert.equal(
      resultBufferTwo[6],
      transporterID,
      "Error: Invalid transporterID"
    );
    assert.equal(
      resultBufferTwo[7],
      bottlingFarmID,
      "Error: Invalid transporterID"
    );
    assert.equal(eventEmitted, true, "Invalid event emitted");
  });
  // 7th Test
  it("Testing smart contract function bottle() that allows a bottling farm to bottle milk", async () => {
    const supplyChain = await SupplyChain.deployed();

    // Declare and Initialize a variable for event
    var eventEmitted = false;

    // Watch the emitted event StoredInFarm()
    var event = supplyChain.Bottled();
    await event.watch((err, res) => {
      eventEmitted = true;
    });

    // Mark an item as Processed by calling function processtItem()
    await supplyChain.bottle(upc, { from: bottlingFarmID });

    // Retrieve the just now saved item from blockchain by calling function fetchItem()
    const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(upc);

    // Verify the result set
    assert.equal(resultBufferTwo[5], 6, "Error: Invalid milk state");
  });
  // 8th Test
  it("Testing smart contract function pack() that allows a bottling farm to pack bottles", async () => {
    const supplyChain = await SupplyChain.deployed();

    // Declare and Initialize a variable for event
    var eventEmitted = false;

    // Watch the emitted event StoredInFarm()
    var event = supplyChain.Packed();
    await event.watch((err, res) => {
      eventEmitted = true;
    });

    // Mark an item as Processed by calling function processtItem()
    await supplyChain.pack(upc, { from: bottlingFarmID });

    // Retrieve the just now saved item from blockchain by calling function fetchItem()
    const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(upc);

    // Verify the result set
    assert.equal(resultBufferTwo[5], 7, "Error: Invalid milk state");
  });
  // 9th Test
  it("Testing smart contract function delivery() that allows a bottling farm to deliver packed bottles", async () => {
    const supplyChain = await SupplyChain.deployed();

    // Declare and Initialize a variable for event
    var eventEmitted = false;

    // Watch the emitted event StoredInFarm()
    var event = supplyChain.Shipped();
    await event.watch((err, res) => {
      eventEmitted = true;
    });

    // Mark an item as Processed by calling function processtItem()
    await supplyChain.delivery(upc, { from: bottlingFarmID });

    // Retrieve the just now saved item from blockchain by calling function fetchItem()
    const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(upc);

    // Verify the result set
    assert.equal(resultBufferTwo[5], 8, "Error: Invalid milk state");
  });
  // 10th Test
  it("Testing smart contract function sellItem() that allows distributor to sell milk", async () => {
    const supplyChain = await SupplyChain.deployed();

    // Declare and Initialize a variable for event
    var eventEmitted = false;

    // Watch the emitted event StoredInFarm()
    var event = supplyChain.ForSale();
    await event.watch((err, res) => {
      eventEmitted = true;
    });

    // Mark an item as Processed by calling function processtItem()
    await supplyChain.sell(upc, productPrice, { from: distributorID });

    // Retrieve the just now saved item from blockchain by calling function fetchItem()
    const resultBufferOne = await supplyChain.fetchItemBufferOne.call(upc);
    const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(upc);

    // Verify the result set
    assert.equal(resultBufferTwo[5], 9, "Error: Invalid milk state");
    assert.equal(
      resultBufferOne[2],
      distributorID,
      "Error: Missing or Invalid ownerID"
    );
    assert.equal(
      resultBufferOne[3],
      originFarmerID,
      "Error: Missing or Invalid originFarmerID"
    );
    assert.equal(
      resultBufferTwo[6],
      transporterID,
      "Error: Invalid transporterID"
    );
    assert.equal(
      resultBufferTwo[7],
      bottlingFarmID,
      "Error: Invalid transporterID"
    );
    assert.equal(
      resultBufferTwo[8],
      distributorID,
      "Error: Invalid distributorID"
    );
    assert.equal(eventEmitted, true, "Invalid event emitted");
  });
  // 11th Test
  it("Testing smart contract function buy() that allows consumer to buy milk", async () => {
    const supplyChain = await SupplyChain.deployed();

    // Declare and Initialize a variable for event
    var eventEmitted = false;

    // Watch the emitted event StoredInFarm()
    var event = supplyChain.Purchased();
    await event.watch((err, res) => {
      eventEmitted = true;
    });

    //Retrieve balances of chain actors
    let farmerBalance = web3.eth.getBalance(originFarmerID);
    let transporterBalance = web3.eth.getBalance(transporterID);
    let bottlingFarmBalance = web3.eth.getBalance(bottlingFarmID);
    let distributorBalance = web3.eth.getBalance(distributorID);
    let consumerBalance = web3.eth.getBalance(consumerID);
    console.log("FarmerBalance before:", farmerBalance.toNumber());
    console.log("TransporterBalance before:", transporterBalance.toNumber());
    console.log("BottlingFarmBalance before:", bottlingFarmBalance.toNumber());
    console.log("DistributorBalance before:", distributorBalance.toNumber());
    console.log("ConsumerBalance before:", consumerBalance.toNumber());

    // Mark an item as Processed by calling function processtItem()
    await supplyChain.buy(upc, {
      from: consumerID,
      value: web3.toWei(10, "ether")
    });

    // Retrieve the just now saved item from blockchain by calling function fetchItem()
    const resultBufferOne = await supplyChain.fetchItemBufferOne.call(upc);
    const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(upc);

    //Retrieve balances of chain actors
    farmerBalance = web3.eth.getBalance(originFarmerID);
    transporterBalance = web3.eth.getBalance(transporterID);
    bottlingFarmBalance = web3.eth.getBalance(bottlingFarmID);
    distributorBalance = web3.eth.getBalance(distributorID);
    consumerBalance = web3.eth.getBalance(consumerID);
    console.log("FarmerBalance after:", farmerBalance.toNumber());
    console.log("TransporterBalance after:", transporterBalance.toNumber());
    console.log("BottlingFarmBalance after:", bottlingFarmBalance.toNumber());
    console.log("DistributorBalance after:", distributorBalance.toNumber());
    console.log("ConsumerBalance after:", consumerBalance.toNumber());
    // Verify the result set
    assert.equal(resultBufferTwo[5], 10, "Error: Invalid milk state");
    assert.equal(
      resultBufferOne[2],
      consumerID,
      "Error: Missing or Invalid ownerID"
    );
    assert.equal(
      resultBufferOne[3],
      originFarmerID,
      "Error: Missing or Invalid originFarmerID"
    );
    assert.equal(
      resultBufferTwo[6],
      transporterID,
      "Error: Invalid transporterID"
    );
    assert.equal(
      resultBufferTwo[7],
      bottlingFarmID,
      "Error: Invalid transporterID"
    );
    assert.equal(
      resultBufferTwo[8],
      distributorID,
      "Error: Invalid distributorID"
    );
    assert.equal(resultBufferTwo[9], consumerID, "Error: Invalid consumerID");
    assert.equal(eventEmitted, true, "Invalid event emitted");

    //let expectedBalance = web3.toBigNumber(web3.toWei(3, 'ether'));
    //let actualBalance = web3.eth.getBalance(accounts[1]);

    //assert.deepEqual(actualBalance, expectedBalance, "Balance incorrect!");
  });
  // 12th Test
  it("Testing smart contract function consumer() that allows a consumer to finally drink his milk!", async () => {
    const supplyChain = await SupplyChain.deployed();

    // Declare and Initialize a variable for event
    var eventEmitted = false;

    // Watch the emitted event StoredInFarm()
    var event = supplyChain.Consumed();
    await event.watch((err, res) => {
      eventEmitted = true;
    });

    // Mark an item as Processed by calling function processtItem()
    await supplyChain.consume(upc, { from: consumerID });

    // Retrieve the just now saved item from blockchain by calling function fetchItem()
    const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(upc);
    // Verify the result set
    assert.equal(resultBufferTwo[5], 11, "Error: Invalid milk state");
  });
});
